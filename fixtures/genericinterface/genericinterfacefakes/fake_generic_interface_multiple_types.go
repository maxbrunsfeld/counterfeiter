// Code generated by counterfeiter. DO NOT EDIT.
package genericinterfacefakes

import (
	"sync"

	"github.com/maxbrunsfeld/counterfeiter/v6/fixtures/genericinterface"
)

type FakeGenericInterfaceMultipleTypes[T genericinterface.CustomTypeT, U genericinterface.CustomTypeU] struct {
	DoSomethingStub        func()
	doSomethingMutex       sync.RWMutex
	doSomethingArgsForCall []struct {
	}
	ReturnTStub        func() T
	returnTMutex       sync.RWMutex
	returnTArgsForCall []struct {
	}
	returnTReturns struct {
		result1 T
	}
	returnTReturnsOnCall map[int]struct {
		result1 T
	}
	ReturnTAndUStub        func() (T, U)
	returnTAndUMutex       sync.RWMutex
	returnTAndUArgsForCall []struct {
	}
	returnTAndUReturns struct {
		result1 T
		result2 U
	}
	returnTAndUReturnsOnCall map[int]struct {
		result1 T
		result2 U
	}
	ReturnUStub        func() U
	returnUMutex       sync.RWMutex
	returnUArgsForCall []struct {
	}
	returnUReturns struct {
		result1 U
	}
	returnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeAndReturnTStub        func(T) T
	takeAndReturnTMutex       sync.RWMutex
	takeAndReturnTArgsForCall []struct {
		arg1 T
	}
	takeAndReturnTReturns struct {
		result1 T
	}
	takeAndReturnTReturnsOnCall map[int]struct {
		result1 T
	}
	TakeAndReturnTAndUStub        func(T, U) (T, U)
	takeAndReturnTAndUMutex       sync.RWMutex
	takeAndReturnTAndUArgsForCall []struct {
		arg1 T
		arg2 U
	}
	takeAndReturnTAndUReturns struct {
		result1 T
		result2 U
	}
	takeAndReturnTAndUReturnsOnCall map[int]struct {
		result1 T
		result2 U
	}
	TakeAndReturnUStub        func(U) U
	takeAndReturnUMutex       sync.RWMutex
	takeAndReturnUArgsForCall []struct {
		arg1 U
	}
	takeAndReturnUReturns struct {
		result1 U
	}
	takeAndReturnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeTStub        func(T)
	takeTMutex       sync.RWMutex
	takeTArgsForCall []struct {
		arg1 T
	}
	TakeTAndReturnUStub        func(T) U
	takeTAndReturnUMutex       sync.RWMutex
	takeTAndReturnUArgsForCall []struct {
		arg1 T
	}
	takeTAndReturnUReturns struct {
		result1 U
	}
	takeTAndReturnUReturnsOnCall map[int]struct {
		result1 U
	}
	TakeTAndUStub        func(T, U)
	takeTAndUMutex       sync.RWMutex
	takeTAndUArgsForCall []struct {
		arg1 T
		arg2 U
	}
	TakeUStub        func(U)
	takeUMutex       sync.RWMutex
	takeUArgsForCall []struct {
		arg1 U
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomething() {
	fake.doSomethingMutex.Lock()
	fake.doSomethingArgsForCall = append(fake.doSomethingArgsForCall, struct {
	}{})
	stub := fake.DoSomethingStub
	fake.recordInvocation("DoSomething", []interface{}{})
	fake.doSomethingMutex.Unlock()
	if stub != nil {
		fake.DoSomethingStub()
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomethingCallCount() int {
	fake.doSomethingMutex.RLock()
	defer fake.doSomethingMutex.RUnlock()
	return len(fake.doSomethingArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) DoSomethingCalls(stub func()) {
	fake.doSomethingMutex.Lock()
	defer fake.doSomethingMutex.Unlock()
	fake.DoSomethingStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnT() T {
	fake.returnTMutex.Lock()
	ret, specificReturn := fake.returnTReturnsOnCall[len(fake.returnTArgsForCall)]
	fake.returnTArgsForCall = append(fake.returnTArgsForCall, struct {
	}{})
	stub := fake.ReturnTStub
	fakeReturns := fake.returnTReturns
	fake.recordInvocation("ReturnT", []interface{}{})
	fake.returnTMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTCallCount() int {
	fake.returnTMutex.RLock()
	defer fake.returnTMutex.RUnlock()
	return len(fake.returnTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTCalls(stub func() T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTReturns(result1 T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = nil
	fake.returnTReturns = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTReturnsOnCall(i int, result1 T) {
	fake.returnTMutex.Lock()
	defer fake.returnTMutex.Unlock()
	fake.ReturnTStub = nil
	if fake.returnTReturnsOnCall == nil {
		fake.returnTReturnsOnCall = make(map[int]struct {
			result1 T
		})
	}
	fake.returnTReturnsOnCall[i] = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndU() (T, U) {
	fake.returnTAndUMutex.Lock()
	ret, specificReturn := fake.returnTAndUReturnsOnCall[len(fake.returnTAndUArgsForCall)]
	fake.returnTAndUArgsForCall = append(fake.returnTAndUArgsForCall, struct {
	}{})
	stub := fake.ReturnTAndUStub
	fakeReturns := fake.returnTAndUReturns
	fake.recordInvocation("ReturnTAndU", []interface{}{})
	fake.returnTAndUMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUCallCount() int {
	fake.returnTAndUMutex.RLock()
	defer fake.returnTAndUMutex.RUnlock()
	return len(fake.returnTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUCalls(stub func() (T, U)) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUReturns(result1 T, result2 U) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = nil
	fake.returnTAndUReturns = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnTAndUReturnsOnCall(i int, result1 T, result2 U) {
	fake.returnTAndUMutex.Lock()
	defer fake.returnTAndUMutex.Unlock()
	fake.ReturnTAndUStub = nil
	if fake.returnTAndUReturnsOnCall == nil {
		fake.returnTAndUReturnsOnCall = make(map[int]struct {
			result1 T
			result2 U
		})
	}
	fake.returnTAndUReturnsOnCall[i] = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnU() U {
	fake.returnUMutex.Lock()
	ret, specificReturn := fake.returnUReturnsOnCall[len(fake.returnUArgsForCall)]
	fake.returnUArgsForCall = append(fake.returnUArgsForCall, struct {
	}{})
	stub := fake.ReturnUStub
	fakeReturns := fake.returnUReturns
	fake.recordInvocation("ReturnU", []interface{}{})
	fake.returnUMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUCallCount() int {
	fake.returnUMutex.RLock()
	defer fake.returnUMutex.RUnlock()
	return len(fake.returnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUCalls(stub func() U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUReturns(result1 U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = nil
	fake.returnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) ReturnUReturnsOnCall(i int, result1 U) {
	fake.returnUMutex.Lock()
	defer fake.returnUMutex.Unlock()
	fake.ReturnUStub = nil
	if fake.returnUReturnsOnCall == nil {
		fake.returnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.returnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnT(arg1 T) T {
	fake.takeAndReturnTMutex.Lock()
	ret, specificReturn := fake.takeAndReturnTReturnsOnCall[len(fake.takeAndReturnTArgsForCall)]
	fake.takeAndReturnTArgsForCall = append(fake.takeAndReturnTArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeAndReturnTStub
	fakeReturns := fake.takeAndReturnTReturns
	fake.recordInvocation("TakeAndReturnT", []interface{}{arg1})
	fake.takeAndReturnTMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTCallCount() int {
	fake.takeAndReturnTMutex.RLock()
	defer fake.takeAndReturnTMutex.RUnlock()
	return len(fake.takeAndReturnTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTCalls(stub func(T) T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTArgsForCall(i int) T {
	fake.takeAndReturnTMutex.RLock()
	defer fake.takeAndReturnTMutex.RUnlock()
	argsForCall := fake.takeAndReturnTArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTReturns(result1 T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = nil
	fake.takeAndReturnTReturns = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTReturnsOnCall(i int, result1 T) {
	fake.takeAndReturnTMutex.Lock()
	defer fake.takeAndReturnTMutex.Unlock()
	fake.TakeAndReturnTStub = nil
	if fake.takeAndReturnTReturnsOnCall == nil {
		fake.takeAndReturnTReturnsOnCall = make(map[int]struct {
			result1 T
		})
	}
	fake.takeAndReturnTReturnsOnCall[i] = struct {
		result1 T
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndU(arg1 T, arg2 U) (T, U) {
	fake.takeAndReturnTAndUMutex.Lock()
	ret, specificReturn := fake.takeAndReturnTAndUReturnsOnCall[len(fake.takeAndReturnTAndUArgsForCall)]
	fake.takeAndReturnTAndUArgsForCall = append(fake.takeAndReturnTAndUArgsForCall, struct {
		arg1 T
		arg2 U
	}{arg1, arg2})
	stub := fake.TakeAndReturnTAndUStub
	fakeReturns := fake.takeAndReturnTAndUReturns
	fake.recordInvocation("TakeAndReturnTAndU", []interface{}{arg1, arg2})
	fake.takeAndReturnTAndUMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUCallCount() int {
	fake.takeAndReturnTAndUMutex.RLock()
	defer fake.takeAndReturnTAndUMutex.RUnlock()
	return len(fake.takeAndReturnTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUCalls(stub func(T, U) (T, U)) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUArgsForCall(i int) (T, U) {
	fake.takeAndReturnTAndUMutex.RLock()
	defer fake.takeAndReturnTAndUMutex.RUnlock()
	argsForCall := fake.takeAndReturnTAndUArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUReturns(result1 T, result2 U) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = nil
	fake.takeAndReturnTAndUReturns = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnTAndUReturnsOnCall(i int, result1 T, result2 U) {
	fake.takeAndReturnTAndUMutex.Lock()
	defer fake.takeAndReturnTAndUMutex.Unlock()
	fake.TakeAndReturnTAndUStub = nil
	if fake.takeAndReturnTAndUReturnsOnCall == nil {
		fake.takeAndReturnTAndUReturnsOnCall = make(map[int]struct {
			result1 T
			result2 U
		})
	}
	fake.takeAndReturnTAndUReturnsOnCall[i] = struct {
		result1 T
		result2 U
	}{result1, result2}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnU(arg1 U) U {
	fake.takeAndReturnUMutex.Lock()
	ret, specificReturn := fake.takeAndReturnUReturnsOnCall[len(fake.takeAndReturnUArgsForCall)]
	fake.takeAndReturnUArgsForCall = append(fake.takeAndReturnUArgsForCall, struct {
		arg1 U
	}{arg1})
	stub := fake.TakeAndReturnUStub
	fakeReturns := fake.takeAndReturnUReturns
	fake.recordInvocation("TakeAndReturnU", []interface{}{arg1})
	fake.takeAndReturnUMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUCallCount() int {
	fake.takeAndReturnUMutex.RLock()
	defer fake.takeAndReturnUMutex.RUnlock()
	return len(fake.takeAndReturnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUCalls(stub func(U) U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUArgsForCall(i int) U {
	fake.takeAndReturnUMutex.RLock()
	defer fake.takeAndReturnUMutex.RUnlock()
	argsForCall := fake.takeAndReturnUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUReturns(result1 U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = nil
	fake.takeAndReturnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeAndReturnUReturnsOnCall(i int, result1 U) {
	fake.takeAndReturnUMutex.Lock()
	defer fake.takeAndReturnUMutex.Unlock()
	fake.TakeAndReturnUStub = nil
	if fake.takeAndReturnUReturnsOnCall == nil {
		fake.takeAndReturnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.takeAndReturnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeT(arg1 T) {
	fake.takeTMutex.Lock()
	fake.takeTArgsForCall = append(fake.takeTArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeTStub
	fake.recordInvocation("TakeT", []interface{}{arg1})
	fake.takeTMutex.Unlock()
	if stub != nil {
		fake.TakeTStub(arg1)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTCallCount() int {
	fake.takeTMutex.RLock()
	defer fake.takeTMutex.RUnlock()
	return len(fake.takeTArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTCalls(stub func(T)) {
	fake.takeTMutex.Lock()
	defer fake.takeTMutex.Unlock()
	fake.TakeTStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTArgsForCall(i int) T {
	fake.takeTMutex.RLock()
	defer fake.takeTMutex.RUnlock()
	argsForCall := fake.takeTArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnU(arg1 T) U {
	fake.takeTAndReturnUMutex.Lock()
	ret, specificReturn := fake.takeTAndReturnUReturnsOnCall[len(fake.takeTAndReturnUArgsForCall)]
	fake.takeTAndReturnUArgsForCall = append(fake.takeTAndReturnUArgsForCall, struct {
		arg1 T
	}{arg1})
	stub := fake.TakeTAndReturnUStub
	fakeReturns := fake.takeTAndReturnUReturns
	fake.recordInvocation("TakeTAndReturnU", []interface{}{arg1})
	fake.takeTAndReturnUMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUCallCount() int {
	fake.takeTAndReturnUMutex.RLock()
	defer fake.takeTAndReturnUMutex.RUnlock()
	return len(fake.takeTAndReturnUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUCalls(stub func(T) U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUArgsForCall(i int) T {
	fake.takeTAndReturnUMutex.RLock()
	defer fake.takeTAndReturnUMutex.RUnlock()
	argsForCall := fake.takeTAndReturnUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUReturns(result1 U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = nil
	fake.takeTAndReturnUReturns = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndReturnUReturnsOnCall(i int, result1 U) {
	fake.takeTAndReturnUMutex.Lock()
	defer fake.takeTAndReturnUMutex.Unlock()
	fake.TakeTAndReturnUStub = nil
	if fake.takeTAndReturnUReturnsOnCall == nil {
		fake.takeTAndReturnUReturnsOnCall = make(map[int]struct {
			result1 U
		})
	}
	fake.takeTAndReturnUReturnsOnCall[i] = struct {
		result1 U
	}{result1}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndU(arg1 T, arg2 U) {
	fake.takeTAndUMutex.Lock()
	fake.takeTAndUArgsForCall = append(fake.takeTAndUArgsForCall, struct {
		arg1 T
		arg2 U
	}{arg1, arg2})
	stub := fake.TakeTAndUStub
	fake.recordInvocation("TakeTAndU", []interface{}{arg1, arg2})
	fake.takeTAndUMutex.Unlock()
	if stub != nil {
		fake.TakeTAndUStub(arg1, arg2)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUCallCount() int {
	fake.takeTAndUMutex.RLock()
	defer fake.takeTAndUMutex.RUnlock()
	return len(fake.takeTAndUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUCalls(stub func(T, U)) {
	fake.takeTAndUMutex.Lock()
	defer fake.takeTAndUMutex.Unlock()
	fake.TakeTAndUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeTAndUArgsForCall(i int) (T, U) {
	fake.takeTAndUMutex.RLock()
	defer fake.takeTAndUMutex.RUnlock()
	argsForCall := fake.takeTAndUArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeU(arg1 U) {
	fake.takeUMutex.Lock()
	fake.takeUArgsForCall = append(fake.takeUArgsForCall, struct {
		arg1 U
	}{arg1})
	stub := fake.TakeUStub
	fake.recordInvocation("TakeU", []interface{}{arg1})
	fake.takeUMutex.Unlock()
	if stub != nil {
		fake.TakeUStub(arg1)
	}
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUCallCount() int {
	fake.takeUMutex.RLock()
	defer fake.takeUMutex.RUnlock()
	return len(fake.takeUArgsForCall)
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUCalls(stub func(U)) {
	fake.takeUMutex.Lock()
	defer fake.takeUMutex.Unlock()
	fake.TakeUStub = stub
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) TakeUArgsForCall(i int) U {
	fake.takeUMutex.RLock()
	defer fake.takeUMutex.RUnlock()
	argsForCall := fake.takeUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.doSomethingMutex.RLock()
	defer fake.doSomethingMutex.RUnlock()
	fake.returnTMutex.RLock()
	defer fake.returnTMutex.RUnlock()
	fake.returnTAndUMutex.RLock()
	defer fake.returnTAndUMutex.RUnlock()
	fake.returnUMutex.RLock()
	defer fake.returnUMutex.RUnlock()
	fake.takeAndReturnTMutex.RLock()
	defer fake.takeAndReturnTMutex.RUnlock()
	fake.takeAndReturnTAndUMutex.RLock()
	defer fake.takeAndReturnTAndUMutex.RUnlock()
	fake.takeAndReturnUMutex.RLock()
	defer fake.takeAndReturnUMutex.RUnlock()
	fake.takeTMutex.RLock()
	defer fake.takeTMutex.RUnlock()
	fake.takeTAndReturnUMutex.RLock()
	defer fake.takeTAndReturnUMutex.RUnlock()
	fake.takeTAndUMutex.RLock()
	defer fake.takeTAndUMutex.RUnlock()
	fake.takeUMutex.RLock()
	defer fake.takeUMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGenericInterfaceMultipleTypes[T, U]) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ genericinterface.GenericInterfaceMultipleTypes[genericinterface.CustomTypeT, genericinterface.CustomTypeU] = new(FakeGenericInterfaceMultipleTypes[genericinterface.CustomTypeT, genericinterface.CustomTypeU])
