// This file was generated by counterfeiter
package packagegenfakes

import (
	"os"
	"sync"
	"time"

	osshim "github.com/maxbrunsfeld/counterfeiter/fixtures/packagegen"
)

type FakeOs struct {
	FindProcessStub        func(pid int) (*os.Process, error)
	findProcessMutex       sync.RWMutex
	findProcessArgsForCall []struct {
		pid int
	}
	findProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	HostnameStub        func() (name string, err error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct{}
	hostnameReturns     struct {
		result1 string
		result2 error
	}
	ExpandStub        func(s string, mapping func(string) string) string
	expandMutex       sync.RWMutex
	expandArgsForCall []struct {
		s       string
		mapping func(string) string
	}
	expandReturns struct {
		result1 string
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct{}
	EnvironStub         func() []string
	environMutex        sync.RWMutex
	environArgsForCall  []struct{}
	environReturns      struct {
		result1 []string
	}
	ChtimesStub        func(name string, atime time.Time, mtime time.Time) error
	chtimesMutex       sync.RWMutex
	chtimesArgsForCall []struct {
		name  string
		atime time.Time
		mtime time.Time
	}
	chtimesReturns struct {
		result1 error
	}
	MkdirAllStub        func(path string, perm os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		path string
		perm os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	ExitStub        func(code int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		code int
	}
	FictionalStub        func(lol ...string)
	fictionalMutex       sync.RWMutex
	fictionalArgsForCall []struct {
		lol []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOs) FindProcess(pid int) (*os.Process, error) {
	fake.findProcessMutex.Lock()
	fake.findProcessArgsForCall = append(fake.findProcessArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("FindProcess", []interface{}{pid})
	fake.findProcessMutex.Unlock()
	if fake.FindProcessStub != nil {
		return fake.FindProcessStub(pid)
	} else {
		return fake.findProcessReturns.result1, fake.findProcessReturns.result2
	}
}

func (fake *FakeOs) FindProcessCallCount() int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return len(fake.findProcessArgsForCall)
}

func (fake *FakeOs) FindProcessArgsForCall(i int) int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return fake.findProcessArgsForCall[i].pid
}

func (fake *FakeOs) FindProcessReturns(result1 *os.Process, result2 error) {
	fake.FindProcessStub = nil
	fake.findProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Hostname() (name string, err error) {
	fake.hostnameMutex.Lock()
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct{}{})
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if fake.HostnameStub != nil {
		return fake.HostnameStub()
	} else {
		return fake.hostnameReturns.result1, fake.hostnameReturns.result2
	}
}

func (fake *FakeOs) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeOs) HostnameReturns(result1 string, result2 error) {
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Expand(s string, mapping func(string) string) string {
	fake.expandMutex.Lock()
	fake.expandArgsForCall = append(fake.expandArgsForCall, struct {
		s       string
		mapping func(string) string
	}{s, mapping})
	fake.recordInvocation("Expand", []interface{}{s, mapping})
	fake.expandMutex.Unlock()
	if fake.ExpandStub != nil {
		return fake.ExpandStub(s, mapping)
	} else {
		return fake.expandReturns.result1
	}
}

func (fake *FakeOs) ExpandCallCount() int {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return len(fake.expandArgsForCall)
}

func (fake *FakeOs) ExpandArgsForCall(i int) (string, func(string) string) {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return fake.expandArgsForCall[i].s, fake.expandArgsForCall[i].mapping
}

func (fake *FakeOs) ExpandReturns(result1 string) {
	fake.ExpandStub = nil
	fake.expandReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct{}{})
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if fake.ClearenvStub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeOs) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeOs) Environ() []string {
	fake.environMutex.Lock()
	fake.environArgsForCall = append(fake.environArgsForCall, struct{}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	} else {
		return fake.environReturns.result1
	}
}

func (fake *FakeOs) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeOs) EnvironReturns(result1 []string) {
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) Chtimes(name string, atime time.Time, mtime time.Time) error {
	fake.chtimesMutex.Lock()
	fake.chtimesArgsForCall = append(fake.chtimesArgsForCall, struct {
		name  string
		atime time.Time
		mtime time.Time
	}{name, atime, mtime})
	fake.recordInvocation("Chtimes", []interface{}{name, atime, mtime})
	fake.chtimesMutex.Unlock()
	if fake.ChtimesStub != nil {
		return fake.ChtimesStub(name, atime, mtime)
	} else {
		return fake.chtimesReturns.result1
	}
}

func (fake *FakeOs) ChtimesCallCount() int {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return len(fake.chtimesArgsForCall)
}

func (fake *FakeOs) ChtimesArgsForCall(i int) (string, time.Time, time.Time) {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return fake.chtimesArgsForCall[i].name, fake.chtimesArgsForCall[i].atime, fake.chtimesArgsForCall[i].mtime
}

func (fake *FakeOs) ChtimesReturns(result1 error) {
	fake.ChtimesStub = nil
	fake.chtimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAll(path string, perm os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		path string
		perm os.FileMode
	}{path, perm})
	fake.recordInvocation("MkdirAll", []interface{}{path, perm})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(path, perm)
	} else {
		return fake.mkdirAllReturns.result1
	}
}

func (fake *FakeOs) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOs) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return fake.mkdirAllArgsForCall[i].path, fake.mkdirAllArgsForCall[i].perm
}

func (fake *FakeOs) MkdirAllReturns(result1 error) {
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Exit(code int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		code int
	}{code})
	fake.recordInvocation("Exit", []interface{}{code})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(code)
	}
}

func (fake *FakeOs) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOs) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return fake.exitArgsForCall[i].code
}

func (fake *FakeOs) Fictional(lol ...string) {
	fake.fictionalMutex.Lock()
	fake.fictionalArgsForCall = append(fake.fictionalArgsForCall, struct {
		lol []string
	}{lol})
	fake.recordInvocation("Fictional", []interface{}{lol})
	fake.fictionalMutex.Unlock()
	if fake.FictionalStub != nil {
		fake.FictionalStub(lol...)
	}
}

func (fake *FakeOs) FictionalCallCount() int {
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	return len(fake.fictionalArgsForCall)
}

func (fake *FakeOs) FictionalArgsForCall(i int) []string {
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	return fake.fictionalArgsForCall[i].lol
}

func (fake *FakeOs) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeOs) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.Os = new(FakeOs)
