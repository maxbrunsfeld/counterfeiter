// Code generated by counterfeiter. DO NOT EDIT.
package packagegenfakes

import (
	"os"
	"sync"
	"time"

	osshim "github.com/maxbrunsfeld/counterfeiter/fixtures/packagegen"
)

type FakeOs struct {
	FindProcessStub        func(pid int) (*os.Process, error)
	findProcessMutex       sync.RWMutex
	findProcessArgsForCall []struct {
		pid int
	}
	findProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	findProcessReturnsOnCall map[int]struct {
		result1 *os.Process
		result2 error
	}
	HostnameStub        func() (name string, err error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct{}
	hostnameReturns     struct {
		result1 string
		result2 error
	}
	hostnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExpandStub        func(s string, mapping func(string) string) string
	expandMutex       sync.RWMutex
	expandArgsForCall []struct {
		s       string
		mapping func(string) string
	}
	expandReturns struct {
		result1 string
	}
	expandReturnsOnCall map[int]struct {
		result1 string
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct{}
	EnvironStub         func() []string
	environMutex        sync.RWMutex
	environArgsForCall  []struct{}
	environReturns      struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	ChtimesStub        func(name string, atime time.Time, mtime time.Time) error
	chtimesMutex       sync.RWMutex
	chtimesArgsForCall []struct {
		name  string
		atime time.Time
		mtime time.Time
	}
	chtimesReturns struct {
		result1 error
	}
	chtimesReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(path string, perm os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		path string
		perm os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	ExitStub        func(code int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		code int
	}
	FictionalStub        func(lol ...string)
	fictionalMutex       sync.RWMutex
	fictionalArgsForCall []struct {
		lol []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOs) FindProcess(pid int) (*os.Process, error) {
	fake.findProcessMutex.Lock()
	ret, specificReturn := fake.findProcessReturnsOnCall[len(fake.findProcessArgsForCall)]
	fake.findProcessArgsForCall = append(fake.findProcessArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("FindProcess", []interface{}{pid})
	fake.findProcessMutex.Unlock()
	if fake.FindProcessStub != nil {
		return fake.FindProcessStub(pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findProcessReturns.result1, fake.findProcessReturns.result2
}

func (fake *FakeOs) FindProcessCallCount() int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return len(fake.findProcessArgsForCall)
}

func (fake *FakeOs) FindProcessArgsForCall(i int) int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return fake.findProcessArgsForCall[i].pid
}

func (fake *FakeOs) FindProcessReturns(result1 *os.Process, result2 error) {
	fake.FindProcessStub = nil
	fake.findProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) FindProcessReturnsOnCall(i int, result1 *os.Process, result2 error) {
	fake.FindProcessStub = nil
	if fake.findProcessReturnsOnCall == nil {
		fake.findProcessReturnsOnCall = make(map[int]struct {
			result1 *os.Process
			result2 error
		})
	}
	fake.findProcessReturnsOnCall[i] = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Hostname() (name string, err error) {
	fake.hostnameMutex.Lock()
	ret, specificReturn := fake.hostnameReturnsOnCall[len(fake.hostnameArgsForCall)]
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct{}{})
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if fake.HostnameStub != nil {
		return fake.HostnameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hostnameReturns.result1, fake.hostnameReturns.result2
}

func (fake *FakeOs) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeOs) HostnameReturns(result1 string, result2 error) {
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) HostnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.HostnameStub = nil
	if fake.hostnameReturnsOnCall == nil {
		fake.hostnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.hostnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Expand(s string, mapping func(string) string) string {
	fake.expandMutex.Lock()
	ret, specificReturn := fake.expandReturnsOnCall[len(fake.expandArgsForCall)]
	fake.expandArgsForCall = append(fake.expandArgsForCall, struct {
		s       string
		mapping func(string) string
	}{s, mapping})
	fake.recordInvocation("Expand", []interface{}{s, mapping})
	fake.expandMutex.Unlock()
	if fake.ExpandStub != nil {
		return fake.ExpandStub(s, mapping)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.expandReturns.result1
}

func (fake *FakeOs) ExpandCallCount() int {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return len(fake.expandArgsForCall)
}

func (fake *FakeOs) ExpandArgsForCall(i int) (string, func(string) string) {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return fake.expandArgsForCall[i].s, fake.expandArgsForCall[i].mapping
}

func (fake *FakeOs) ExpandReturns(result1 string) {
	fake.ExpandStub = nil
	fake.expandReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandReturnsOnCall(i int, result1 string) {
	fake.ExpandStub = nil
	if fake.expandReturnsOnCall == nil {
		fake.expandReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.expandReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct{}{})
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if fake.ClearenvStub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeOs) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeOs) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct{}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.environReturns.result1
}

func (fake *FakeOs) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeOs) EnvironReturns(result1 []string) {
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) EnvironReturnsOnCall(i int, result1 []string) {
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) Chtimes(name string, atime time.Time, mtime time.Time) error {
	fake.chtimesMutex.Lock()
	ret, specificReturn := fake.chtimesReturnsOnCall[len(fake.chtimesArgsForCall)]
	fake.chtimesArgsForCall = append(fake.chtimesArgsForCall, struct {
		name  string
		atime time.Time
		mtime time.Time
	}{name, atime, mtime})
	fake.recordInvocation("Chtimes", []interface{}{name, atime, mtime})
	fake.chtimesMutex.Unlock()
	if fake.ChtimesStub != nil {
		return fake.ChtimesStub(name, atime, mtime)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.chtimesReturns.result1
}

func (fake *FakeOs) ChtimesCallCount() int {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return len(fake.chtimesArgsForCall)
}

func (fake *FakeOs) ChtimesArgsForCall(i int) (string, time.Time, time.Time) {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return fake.chtimesArgsForCall[i].name, fake.chtimesArgsForCall[i].atime, fake.chtimesArgsForCall[i].mtime
}

func (fake *FakeOs) ChtimesReturns(result1 error) {
	fake.ChtimesStub = nil
	fake.chtimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChtimesReturnsOnCall(i int, result1 error) {
	fake.ChtimesStub = nil
	if fake.chtimesReturnsOnCall == nil {
		fake.chtimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chtimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAll(path string, perm os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		path string
		perm os.FileMode
	}{path, perm})
	fake.recordInvocation("MkdirAll", []interface{}{path, perm})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(path, perm)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mkdirAllReturns.result1
}

func (fake *FakeOs) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOs) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return fake.mkdirAllArgsForCall[i].path, fake.mkdirAllArgsForCall[i].perm
}

func (fake *FakeOs) MkdirAllReturns(result1 error) {
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Exit(code int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		code int
	}{code})
	fake.recordInvocation("Exit", []interface{}{code})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(code)
	}
}

func (fake *FakeOs) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOs) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return fake.exitArgsForCall[i].code
}

func (fake *FakeOs) Fictional(lol ...string) {
	fake.fictionalMutex.Lock()
	fake.fictionalArgsForCall = append(fake.fictionalArgsForCall, struct {
		lol []string
	}{lol})
	fake.recordInvocation("Fictional", []interface{}{lol})
	fake.fictionalMutex.Unlock()
	if fake.FictionalStub != nil {
		fake.FictionalStub(lol...)
	}
}

func (fake *FakeOs) FictionalCallCount() int {
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	return len(fake.fictionalArgsForCall)
}

func (fake *FakeOs) FictionalArgsForCall(i int) []string {
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	return fake.fictionalArgsForCall[i].lol
}

func (fake *FakeOs) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.fictionalMutex.RLock()
	defer fake.fictionalMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOs) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.Os = new(FakeOs)
