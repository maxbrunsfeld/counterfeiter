// Code generated by counterfeiter. DO NOT EDIT.
package osshimfakes

import (
	"io/fs"
	"os"
	"sync"
	"time"

	"github.com/maxbrunsfeld/counterfeiter/v6/fixtures/packagemode/osshim"
)

type FakeOs struct {
	ChdirStub        func(string) error
	chdirMutex       sync.RWMutex
	chdirArgsForCall []struct {
		arg1 string
	}
	chdirReturns struct {
		result1 error
	}
	chdirReturnsOnCall map[int]struct {
		result1 error
	}
	ChmodStub        func(string, fs.FileMode) error
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		arg1 string
		arg2 fs.FileMode
	}
	chmodReturns struct {
		result1 error
	}
	chmodReturnsOnCall map[int]struct {
		result1 error
	}
	ChownStub        func(string, int, int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	ChtimesStub        func(string, time.Time, time.Time) error
	chtimesMutex       sync.RWMutex
	chtimesArgsForCall []struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}
	chtimesReturns struct {
		result1 error
	}
	chtimesReturnsOnCall map[int]struct {
		result1 error
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct {
	}
	CreateStub        func(string) (*os.File, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
	}
	createReturns struct {
		result1 *os.File
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	CreateTempStub        func(string, string) (*os.File, error)
	createTempMutex       sync.RWMutex
	createTempArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createTempReturns struct {
		result1 *os.File
		result2 error
	}
	createTempReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	DirFSStub        func(string) fs.FS
	dirFSMutex       sync.RWMutex
	dirFSArgsForCall []struct {
		arg1 string
	}
	dirFSReturns struct {
		result1 fs.FS
	}
	dirFSReturnsOnCall map[int]struct {
		result1 fs.FS
	}
	EnvironStub        func() []string
	environMutex       sync.RWMutex
	environArgsForCall []struct {
	}
	environReturns struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	ExecutableStub        func() (string, error)
	executableMutex       sync.RWMutex
	executableArgsForCall []struct {
	}
	executableReturns struct {
		result1 string
		result2 error
	}
	executableReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExitStub        func(int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		arg1 int
	}
	ExpandStub        func(string, func(string) string) string
	expandMutex       sync.RWMutex
	expandArgsForCall []struct {
		arg1 string
		arg2 func(string) string
	}
	expandReturns struct {
		result1 string
	}
	expandReturnsOnCall map[int]struct {
		result1 string
	}
	ExpandEnvStub        func(string) string
	expandEnvMutex       sync.RWMutex
	expandEnvArgsForCall []struct {
		arg1 string
	}
	expandEnvReturns struct {
		result1 string
	}
	expandEnvReturnsOnCall map[int]struct {
		result1 string
	}
	FindProcessStub        func(int) (*os.Process, error)
	findProcessMutex       sync.RWMutex
	findProcessArgsForCall []struct {
		arg1 int
	}
	findProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	findProcessReturnsOnCall map[int]struct {
		result1 *os.Process
		result2 error
	}
	GetegidStub        func() int
	getegidMutex       sync.RWMutex
	getegidArgsForCall []struct {
	}
	getegidReturns struct {
		result1 int
	}
	getegidReturnsOnCall map[int]struct {
		result1 int
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	GeteuidStub        func() int
	geteuidMutex       sync.RWMutex
	geteuidArgsForCall []struct {
	}
	geteuidReturns struct {
		result1 int
	}
	geteuidReturnsOnCall map[int]struct {
		result1 int
	}
	GetgidStub        func() int
	getgidMutex       sync.RWMutex
	getgidArgsForCall []struct {
	}
	getgidReturns struct {
		result1 int
	}
	getgidReturnsOnCall map[int]struct {
		result1 int
	}
	GetgroupsStub        func() ([]int, error)
	getgroupsMutex       sync.RWMutex
	getgroupsArgsForCall []struct {
	}
	getgroupsReturns struct {
		result1 []int
		result2 error
	}
	getgroupsReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	GetpagesizeStub        func() int
	getpagesizeMutex       sync.RWMutex
	getpagesizeArgsForCall []struct {
	}
	getpagesizeReturns struct {
		result1 int
	}
	getpagesizeReturnsOnCall map[int]struct {
		result1 int
	}
	GetpidStub        func() int
	getpidMutex       sync.RWMutex
	getpidArgsForCall []struct {
	}
	getpidReturns struct {
		result1 int
	}
	getpidReturnsOnCall map[int]struct {
		result1 int
	}
	GetppidStub        func() int
	getppidMutex       sync.RWMutex
	getppidArgsForCall []struct {
	}
	getppidReturns struct {
		result1 int
	}
	getppidReturnsOnCall map[int]struct {
		result1 int
	}
	GetuidStub        func() int
	getuidMutex       sync.RWMutex
	getuidArgsForCall []struct {
	}
	getuidReturns struct {
		result1 int
	}
	getuidReturnsOnCall map[int]struct {
		result1 int
	}
	GetwdStub        func() (string, error)
	getwdMutex       sync.RWMutex
	getwdArgsForCall []struct {
	}
	getwdReturns struct {
		result1 string
		result2 error
	}
	getwdReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HostnameStub        func() (string, error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct {
	}
	hostnameReturns struct {
		result1 string
		result2 error
	}
	hostnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IsExistStub        func(error) bool
	isExistMutex       sync.RWMutex
	isExistArgsForCall []struct {
		arg1 error
	}
	isExistReturns struct {
		result1 bool
	}
	isExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsNotExistStub        func(error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		arg1 error
	}
	isNotExistReturns struct {
		result1 bool
	}
	isNotExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsPathSeparatorStub        func(uint8) bool
	isPathSeparatorMutex       sync.RWMutex
	isPathSeparatorArgsForCall []struct {
		arg1 uint8
	}
	isPathSeparatorReturns struct {
		result1 bool
	}
	isPathSeparatorReturnsOnCall map[int]struct {
		result1 bool
	}
	IsPermissionStub        func(error) bool
	isPermissionMutex       sync.RWMutex
	isPermissionArgsForCall []struct {
		arg1 error
	}
	isPermissionReturns struct {
		result1 bool
	}
	isPermissionReturnsOnCall map[int]struct {
		result1 bool
	}
	IsTimeoutStub        func(error) bool
	isTimeoutMutex       sync.RWMutex
	isTimeoutArgsForCall []struct {
		arg1 error
	}
	isTimeoutReturns struct {
		result1 bool
	}
	isTimeoutReturnsOnCall map[int]struct {
		result1 bool
	}
	LchownStub        func(string, int, int) error
	lchownMutex       sync.RWMutex
	lchownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	lchownReturns struct {
		result1 error
	}
	lchownReturnsOnCall map[int]struct {
		result1 error
	}
	LinkStub        func(string, string) error
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	linkReturns struct {
		result1 error
	}
	linkReturnsOnCall map[int]struct {
		result1 error
	}
	LookupEnvStub        func(string) (string, bool)
	lookupEnvMutex       sync.RWMutex
	lookupEnvArgsForCall []struct {
		arg1 string
	}
	lookupEnvReturns struct {
		result1 string
		result2 bool
	}
	lookupEnvReturnsOnCall map[int]struct {
		result1 string
		result2 bool
	}
	LstatStub        func(string) (fs.FileInfo, error)
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		arg1 string
	}
	lstatReturns struct {
		result1 fs.FileInfo
		result2 error
	}
	lstatReturnsOnCall map[int]struct {
		result1 fs.FileInfo
		result2 error
	}
	MkdirStub        func(string, fs.FileMode) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		arg1 string
		arg2 fs.FileMode
	}
	mkdirReturns struct {
		result1 error
	}
	mkdirReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(string, fs.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
		arg2 fs.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirTempStub        func(string, string) (string, error)
	mkdirTempMutex       sync.RWMutex
	mkdirTempArgsForCall []struct {
		arg1 string
		arg2 string
	}
	mkdirTempReturns struct {
		result1 string
		result2 error
	}
	mkdirTempReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	NewFileStub        func(uintptr, string) *os.File
	newFileMutex       sync.RWMutex
	newFileArgsForCall []struct {
		arg1 uintptr
		arg2 string
	}
	newFileReturns struct {
		result1 *os.File
	}
	newFileReturnsOnCall map[int]struct {
		result1 *os.File
	}
	NewSyscallErrorStub        func(string, error) error
	newSyscallErrorMutex       sync.RWMutex
	newSyscallErrorArgsForCall []struct {
		arg1 string
		arg2 error
	}
	newSyscallErrorReturns struct {
		result1 error
	}
	newSyscallErrorReturnsOnCall map[int]struct {
		result1 error
	}
	OpenStub        func(string) (*os.File, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
	}
	openReturns struct {
		result1 *os.File
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	OpenFileStub        func(string, int, fs.FileMode) (*os.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 fs.FileMode
	}
	openFileReturns struct {
		result1 *os.File
		result2 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	PipeStub        func() (*os.File, *os.File, error)
	pipeMutex       sync.RWMutex
	pipeArgsForCall []struct {
	}
	pipeReturns struct {
		result1 *os.File
		result2 *os.File
		result3 error
	}
	pipeReturnsOnCall map[int]struct {
		result1 *os.File
		result2 *os.File
		result3 error
	}
	ReadDirStub        func(string) ([]fs.DirEntry, error)
	readDirMutex       sync.RWMutex
	readDirArgsForCall []struct {
		arg1 string
	}
	readDirReturns struct {
		result1 []fs.DirEntry
		result2 error
	}
	readDirReturnsOnCall map[int]struct {
		result1 []fs.DirEntry
		result2 error
	}
	ReadFileStub        func(string) ([]byte, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 string
	}
	readFileReturns struct {
		result1 []byte
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadlinkStub        func(string) (string, error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		arg1 string
	}
	readlinkReturns struct {
		result1 string
		result2 error
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string, string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	SameFileStub        func(fs.FileInfo, fs.FileInfo) bool
	sameFileMutex       sync.RWMutex
	sameFileArgsForCall []struct {
		arg1 fs.FileInfo
		arg2 fs.FileInfo
	}
	sameFileReturns struct {
		result1 bool
	}
	sameFileReturnsOnCall map[int]struct {
		result1 bool
	}
	SetenvStub        func(string, string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setenvReturns struct {
		result1 error
	}
	setenvReturnsOnCall map[int]struct {
		result1 error
	}
	StartProcessStub        func(string, []string, *os.ProcAttr) (*os.Process, error)
	startProcessMutex       sync.RWMutex
	startProcessArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 *os.ProcAttr
	}
	startProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	startProcessReturnsOnCall map[int]struct {
		result1 *os.Process
		result2 error
	}
	StatStub        func(string) (fs.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 fs.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 fs.FileInfo
		result2 error
	}
	SymlinkStub        func(string, string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	TempDirStub        func() string
	tempDirMutex       sync.RWMutex
	tempDirArgsForCall []struct {
	}
	tempDirReturns struct {
		result1 string
	}
	tempDirReturnsOnCall map[int]struct {
		result1 string
	}
	TruncateStub        func(string, int64) error
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	truncateReturns struct {
		result1 error
	}
	truncateReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetenvStub        func(string) error
	unsetenvMutex       sync.RWMutex
	unsetenvArgsForCall []struct {
		arg1 string
	}
	unsetenvReturns struct {
		result1 error
	}
	unsetenvReturnsOnCall map[int]struct {
		result1 error
	}
	UserCacheDirStub        func() (string, error)
	userCacheDirMutex       sync.RWMutex
	userCacheDirArgsForCall []struct {
	}
	userCacheDirReturns struct {
		result1 string
		result2 error
	}
	userCacheDirReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UserConfigDirStub        func() (string, error)
	userConfigDirMutex       sync.RWMutex
	userConfigDirArgsForCall []struct {
	}
	userConfigDirReturns struct {
		result1 string
		result2 error
	}
	userConfigDirReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UserHomeDirStub        func() (string, error)
	userHomeDirMutex       sync.RWMutex
	userHomeDirArgsForCall []struct {
	}
	userHomeDirReturns struct {
		result1 string
		result2 error
	}
	userHomeDirReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	WriteFileStub        func(string, []byte, fs.FileMode) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 fs.FileMode
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOs) Chdir(arg1 string) error {
	fake.chdirMutex.Lock()
	ret, specificReturn := fake.chdirReturnsOnCall[len(fake.chdirArgsForCall)]
	fake.chdirArgsForCall = append(fake.chdirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChdirStub
	fakeReturns := fake.chdirReturns
	fake.recordInvocation("Chdir", []interface{}{arg1})
	fake.chdirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ChdirCallCount() int {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return len(fake.chdirArgsForCall)
}

func (fake *FakeOs) ChdirCalls(stub func(string) error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = stub
}

func (fake *FakeOs) ChdirArgsForCall(i int) string {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	argsForCall := fake.chdirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ChdirReturns(result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	fake.chdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChdirReturnsOnCall(i int, result1 error) {
	fake.chdirMutex.Lock()
	defer fake.chdirMutex.Unlock()
	fake.ChdirStub = nil
	if fake.chdirReturnsOnCall == nil {
		fake.chdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chmod(arg1 string, arg2 fs.FileMode) error {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		arg1 string
		arg2 fs.FileMode
	}{arg1, arg2})
	stub := fake.ChmodStub
	fakeReturns := fake.chmodReturns
	fake.recordInvocation("Chmod", []interface{}{arg1, arg2})
	fake.chmodMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeOs) ChmodCalls(stub func(string, fs.FileMode) error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = stub
}

func (fake *FakeOs) ChmodArgsForCall(i int) (string, fs.FileMode) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	argsForCall := fake.chmodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) ChmodReturns(result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChmodReturnsOnCall(i int, result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chown(arg1 string, arg2 int, arg3 int) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ChownStub
	fakeReturns := fake.chownReturns
	fake.recordInvocation("Chown", []interface{}{arg1, arg2, arg3})
	fake.chownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeOs) ChownCalls(stub func(string, int, int) error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeOs) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) ChownReturns(result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChownReturnsOnCall(i int, result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chtimes(arg1 string, arg2 time.Time, arg3 time.Time) error {
	fake.chtimesMutex.Lock()
	ret, specificReturn := fake.chtimesReturnsOnCall[len(fake.chtimesArgsForCall)]
	fake.chtimesArgsForCall = append(fake.chtimesArgsForCall, struct {
		arg1 string
		arg2 time.Time
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.ChtimesStub
	fakeReturns := fake.chtimesReturns
	fake.recordInvocation("Chtimes", []interface{}{arg1, arg2, arg3})
	fake.chtimesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ChtimesCallCount() int {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return len(fake.chtimesArgsForCall)
}

func (fake *FakeOs) ChtimesCalls(stub func(string, time.Time, time.Time) error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = stub
}

func (fake *FakeOs) ChtimesArgsForCall(i int) (string, time.Time, time.Time) {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	argsForCall := fake.chtimesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) ChtimesReturns(result1 error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = nil
	fake.chtimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) ChtimesReturnsOnCall(i int, result1 error) {
	fake.chtimesMutex.Lock()
	defer fake.chtimesMutex.Unlock()
	fake.ChtimesStub = nil
	if fake.chtimesReturnsOnCall == nil {
		fake.chtimesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chtimesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct {
	}{})
	stub := fake.ClearenvStub
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if stub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeOs) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeOs) ClearenvCalls(stub func()) {
	fake.clearenvMutex.Lock()
	defer fake.clearenvMutex.Unlock()
	fake.ClearenvStub = stub
}

func (fake *FakeOs) Create(arg1 string) (*os.File, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeOs) CreateCalls(stub func(string) (*os.File, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeOs) CreateArgsForCall(i int) string {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) CreateReturns(result1 *os.File, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) CreateReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) CreateTemp(arg1 string, arg2 string) (*os.File, error) {
	fake.createTempMutex.Lock()
	ret, specificReturn := fake.createTempReturnsOnCall[len(fake.createTempArgsForCall)]
	fake.createTempArgsForCall = append(fake.createTempArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateTempStub
	fakeReturns := fake.createTempReturns
	fake.recordInvocation("CreateTemp", []interface{}{arg1, arg2})
	fake.createTempMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) CreateTempCallCount() int {
	fake.createTempMutex.RLock()
	defer fake.createTempMutex.RUnlock()
	return len(fake.createTempArgsForCall)
}

func (fake *FakeOs) CreateTempCalls(stub func(string, string) (*os.File, error)) {
	fake.createTempMutex.Lock()
	defer fake.createTempMutex.Unlock()
	fake.CreateTempStub = stub
}

func (fake *FakeOs) CreateTempArgsForCall(i int) (string, string) {
	fake.createTempMutex.RLock()
	defer fake.createTempMutex.RUnlock()
	argsForCall := fake.createTempArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) CreateTempReturns(result1 *os.File, result2 error) {
	fake.createTempMutex.Lock()
	defer fake.createTempMutex.Unlock()
	fake.CreateTempStub = nil
	fake.createTempReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) CreateTempReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.createTempMutex.Lock()
	defer fake.createTempMutex.Unlock()
	fake.CreateTempStub = nil
	if fake.createTempReturnsOnCall == nil {
		fake.createTempReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.createTempReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) DirFS(arg1 string) fs.FS {
	fake.dirFSMutex.Lock()
	ret, specificReturn := fake.dirFSReturnsOnCall[len(fake.dirFSArgsForCall)]
	fake.dirFSArgsForCall = append(fake.dirFSArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DirFSStub
	fakeReturns := fake.dirFSReturns
	fake.recordInvocation("DirFS", []interface{}{arg1})
	fake.dirFSMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) DirFSCallCount() int {
	fake.dirFSMutex.RLock()
	defer fake.dirFSMutex.RUnlock()
	return len(fake.dirFSArgsForCall)
}

func (fake *FakeOs) DirFSCalls(stub func(string) fs.FS) {
	fake.dirFSMutex.Lock()
	defer fake.dirFSMutex.Unlock()
	fake.DirFSStub = stub
}

func (fake *FakeOs) DirFSArgsForCall(i int) string {
	fake.dirFSMutex.RLock()
	defer fake.dirFSMutex.RUnlock()
	argsForCall := fake.dirFSArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) DirFSReturns(result1 fs.FS) {
	fake.dirFSMutex.Lock()
	defer fake.dirFSMutex.Unlock()
	fake.DirFSStub = nil
	fake.dirFSReturns = struct {
		result1 fs.FS
	}{result1}
}

func (fake *FakeOs) DirFSReturnsOnCall(i int, result1 fs.FS) {
	fake.dirFSMutex.Lock()
	defer fake.dirFSMutex.Unlock()
	fake.DirFSStub = nil
	if fake.dirFSReturnsOnCall == nil {
		fake.dirFSReturnsOnCall = make(map[int]struct {
			result1 fs.FS
		})
	}
	fake.dirFSReturnsOnCall[i] = struct {
		result1 fs.FS
	}{result1}
}

func (fake *FakeOs) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct {
	}{})
	stub := fake.EnvironStub
	fakeReturns := fake.environReturns
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeOs) EnvironCalls(stub func() []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = stub
}

func (fake *FakeOs) EnvironReturns(result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) EnvironReturnsOnCall(i int, result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) Executable() (string, error) {
	fake.executableMutex.Lock()
	ret, specificReturn := fake.executableReturnsOnCall[len(fake.executableArgsForCall)]
	fake.executableArgsForCall = append(fake.executableArgsForCall, struct {
	}{})
	stub := fake.ExecutableStub
	fakeReturns := fake.executableReturns
	fake.recordInvocation("Executable", []interface{}{})
	fake.executableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) ExecutableCallCount() int {
	fake.executableMutex.RLock()
	defer fake.executableMutex.RUnlock()
	return len(fake.executableArgsForCall)
}

func (fake *FakeOs) ExecutableCalls(stub func() (string, error)) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = stub
}

func (fake *FakeOs) ExecutableReturns(result1 string, result2 error) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = nil
	fake.executableReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ExecutableReturnsOnCall(i int, result1 string, result2 error) {
	fake.executableMutex.Lock()
	defer fake.executableMutex.Unlock()
	fake.ExecutableStub = nil
	if fake.executableReturnsOnCall == nil {
		fake.executableReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.executableReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Exit(arg1 int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ExitStub
	fake.recordInvocation("Exit", []interface{}{arg1})
	fake.exitMutex.Unlock()
	if stub != nil {
		fake.ExitStub(arg1)
	}
}

func (fake *FakeOs) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOs) ExitCalls(stub func(int)) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = stub
}

func (fake *FakeOs) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	argsForCall := fake.exitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) Expand(arg1 string, arg2 func(string) string) string {
	fake.expandMutex.Lock()
	ret, specificReturn := fake.expandReturnsOnCall[len(fake.expandArgsForCall)]
	fake.expandArgsForCall = append(fake.expandArgsForCall, struct {
		arg1 string
		arg2 func(string) string
	}{arg1, arg2})
	stub := fake.ExpandStub
	fakeReturns := fake.expandReturns
	fake.recordInvocation("Expand", []interface{}{arg1, arg2})
	fake.expandMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ExpandCallCount() int {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return len(fake.expandArgsForCall)
}

func (fake *FakeOs) ExpandCalls(stub func(string, func(string) string) string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = stub
}

func (fake *FakeOs) ExpandArgsForCall(i int) (string, func(string) string) {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	argsForCall := fake.expandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) ExpandReturns(result1 string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = nil
	fake.expandReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandReturnsOnCall(i int, result1 string) {
	fake.expandMutex.Lock()
	defer fake.expandMutex.Unlock()
	fake.ExpandStub = nil
	if fake.expandReturnsOnCall == nil {
		fake.expandReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.expandReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandEnv(arg1 string) string {
	fake.expandEnvMutex.Lock()
	ret, specificReturn := fake.expandEnvReturnsOnCall[len(fake.expandEnvArgsForCall)]
	fake.expandEnvArgsForCall = append(fake.expandEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExpandEnvStub
	fakeReturns := fake.expandEnvReturns
	fake.recordInvocation("ExpandEnv", []interface{}{arg1})
	fake.expandEnvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) ExpandEnvCallCount() int {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	return len(fake.expandEnvArgsForCall)
}

func (fake *FakeOs) ExpandEnvCalls(stub func(string) string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = stub
}

func (fake *FakeOs) ExpandEnvArgsForCall(i int) string {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	argsForCall := fake.expandEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ExpandEnvReturns(result1 string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = nil
	fake.expandEnvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandEnvReturnsOnCall(i int, result1 string) {
	fake.expandEnvMutex.Lock()
	defer fake.expandEnvMutex.Unlock()
	fake.ExpandEnvStub = nil
	if fake.expandEnvReturnsOnCall == nil {
		fake.expandEnvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.expandEnvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) FindProcess(arg1 int) (*os.Process, error) {
	fake.findProcessMutex.Lock()
	ret, specificReturn := fake.findProcessReturnsOnCall[len(fake.findProcessArgsForCall)]
	fake.findProcessArgsForCall = append(fake.findProcessArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.FindProcessStub
	fakeReturns := fake.findProcessReturns
	fake.recordInvocation("FindProcess", []interface{}{arg1})
	fake.findProcessMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) FindProcessCallCount() int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return len(fake.findProcessArgsForCall)
}

func (fake *FakeOs) FindProcessCalls(stub func(int) (*os.Process, error)) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = stub
}

func (fake *FakeOs) FindProcessArgsForCall(i int) int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	argsForCall := fake.findProcessArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) FindProcessReturns(result1 *os.Process, result2 error) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = nil
	fake.findProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) FindProcessReturnsOnCall(i int, result1 *os.Process, result2 error) {
	fake.findProcessMutex.Lock()
	defer fake.findProcessMutex.Unlock()
	fake.FindProcessStub = nil
	if fake.findProcessReturnsOnCall == nil {
		fake.findProcessReturnsOnCall = make(map[int]struct {
			result1 *os.Process
			result2 error
		})
	}
	fake.findProcessReturnsOnCall[i] = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Getegid() int {
	fake.getegidMutex.Lock()
	ret, specificReturn := fake.getegidReturnsOnCall[len(fake.getegidArgsForCall)]
	fake.getegidArgsForCall = append(fake.getegidArgsForCall, struct {
	}{})
	stub := fake.GetegidStub
	fakeReturns := fake.getegidReturns
	fake.recordInvocation("Getegid", []interface{}{})
	fake.getegidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetegidCallCount() int {
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	return len(fake.getegidArgsForCall)
}

func (fake *FakeOs) GetegidCalls(stub func() int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = stub
}

func (fake *FakeOs) GetegidReturns(result1 int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = nil
	fake.getegidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetegidReturnsOnCall(i int, result1 int) {
	fake.getegidMutex.Lock()
	defer fake.getegidMutex.Unlock()
	fake.GetegidStub = nil
	if fake.getegidReturnsOnCall == nil {
		fake.getegidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getegidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeOs) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeOs) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Geteuid() int {
	fake.geteuidMutex.Lock()
	ret, specificReturn := fake.geteuidReturnsOnCall[len(fake.geteuidArgsForCall)]
	fake.geteuidArgsForCall = append(fake.geteuidArgsForCall, struct {
	}{})
	stub := fake.GeteuidStub
	fakeReturns := fake.geteuidReturns
	fake.recordInvocation("Geteuid", []interface{}{})
	fake.geteuidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GeteuidCallCount() int {
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	return len(fake.geteuidArgsForCall)
}

func (fake *FakeOs) GeteuidCalls(stub func() int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = stub
}

func (fake *FakeOs) GeteuidReturns(result1 int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = nil
	fake.geteuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GeteuidReturnsOnCall(i int, result1 int) {
	fake.geteuidMutex.Lock()
	defer fake.geteuidMutex.Unlock()
	fake.GeteuidStub = nil
	if fake.geteuidReturnsOnCall == nil {
		fake.geteuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.geteuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgid() int {
	fake.getgidMutex.Lock()
	ret, specificReturn := fake.getgidReturnsOnCall[len(fake.getgidArgsForCall)]
	fake.getgidArgsForCall = append(fake.getgidArgsForCall, struct {
	}{})
	stub := fake.GetgidStub
	fakeReturns := fake.getgidReturns
	fake.recordInvocation("Getgid", []interface{}{})
	fake.getgidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetgidCallCount() int {
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	return len(fake.getgidArgsForCall)
}

func (fake *FakeOs) GetgidCalls(stub func() int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = stub
}

func (fake *FakeOs) GetgidReturns(result1 int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = nil
	fake.getgidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetgidReturnsOnCall(i int, result1 int) {
	fake.getgidMutex.Lock()
	defer fake.getgidMutex.Unlock()
	fake.GetgidStub = nil
	if fake.getgidReturnsOnCall == nil {
		fake.getgidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getgidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgroups() ([]int, error) {
	fake.getgroupsMutex.Lock()
	ret, specificReturn := fake.getgroupsReturnsOnCall[len(fake.getgroupsArgsForCall)]
	fake.getgroupsArgsForCall = append(fake.getgroupsArgsForCall, struct {
	}{})
	stub := fake.GetgroupsStub
	fakeReturns := fake.getgroupsReturns
	fake.recordInvocation("Getgroups", []interface{}{})
	fake.getgroupsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) GetgroupsCallCount() int {
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	return len(fake.getgroupsArgsForCall)
}

func (fake *FakeOs) GetgroupsCalls(stub func() ([]int, error)) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = stub
}

func (fake *FakeOs) GetgroupsReturns(result1 []int, result2 error) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = nil
	fake.getgroupsReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) GetgroupsReturnsOnCall(i int, result1 []int, result2 error) {
	fake.getgroupsMutex.Lock()
	defer fake.getgroupsMutex.Unlock()
	fake.GetgroupsStub = nil
	if fake.getgroupsReturnsOnCall == nil {
		fake.getgroupsReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getgroupsReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Getpagesize() int {
	fake.getpagesizeMutex.Lock()
	ret, specificReturn := fake.getpagesizeReturnsOnCall[len(fake.getpagesizeArgsForCall)]
	fake.getpagesizeArgsForCall = append(fake.getpagesizeArgsForCall, struct {
	}{})
	stub := fake.GetpagesizeStub
	fakeReturns := fake.getpagesizeReturns
	fake.recordInvocation("Getpagesize", []interface{}{})
	fake.getpagesizeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetpagesizeCallCount() int {
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	return len(fake.getpagesizeArgsForCall)
}

func (fake *FakeOs) GetpagesizeCalls(stub func() int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = stub
}

func (fake *FakeOs) GetpagesizeReturns(result1 int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = nil
	fake.getpagesizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetpagesizeReturnsOnCall(i int, result1 int) {
	fake.getpagesizeMutex.Lock()
	defer fake.getpagesizeMutex.Unlock()
	fake.GetpagesizeStub = nil
	if fake.getpagesizeReturnsOnCall == nil {
		fake.getpagesizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpagesizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getpid() int {
	fake.getpidMutex.Lock()
	ret, specificReturn := fake.getpidReturnsOnCall[len(fake.getpidArgsForCall)]
	fake.getpidArgsForCall = append(fake.getpidArgsForCall, struct {
	}{})
	stub := fake.GetpidStub
	fakeReturns := fake.getpidReturns
	fake.recordInvocation("Getpid", []interface{}{})
	fake.getpidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetpidCallCount() int {
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	return len(fake.getpidArgsForCall)
}

func (fake *FakeOs) GetpidCalls(stub func() int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = stub
}

func (fake *FakeOs) GetpidReturns(result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	fake.getpidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetpidReturnsOnCall(i int, result1 int) {
	fake.getpidMutex.Lock()
	defer fake.getpidMutex.Unlock()
	fake.GetpidStub = nil
	if fake.getpidReturnsOnCall == nil {
		fake.getpidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getpidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getppid() int {
	fake.getppidMutex.Lock()
	ret, specificReturn := fake.getppidReturnsOnCall[len(fake.getppidArgsForCall)]
	fake.getppidArgsForCall = append(fake.getppidArgsForCall, struct {
	}{})
	stub := fake.GetppidStub
	fakeReturns := fake.getppidReturns
	fake.recordInvocation("Getppid", []interface{}{})
	fake.getppidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetppidCallCount() int {
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	return len(fake.getppidArgsForCall)
}

func (fake *FakeOs) GetppidCalls(stub func() int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = stub
}

func (fake *FakeOs) GetppidReturns(result1 int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = nil
	fake.getppidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetppidReturnsOnCall(i int, result1 int) {
	fake.getppidMutex.Lock()
	defer fake.getppidMutex.Unlock()
	fake.GetppidStub = nil
	if fake.getppidReturnsOnCall == nil {
		fake.getppidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getppidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getuid() int {
	fake.getuidMutex.Lock()
	ret, specificReturn := fake.getuidReturnsOnCall[len(fake.getuidArgsForCall)]
	fake.getuidArgsForCall = append(fake.getuidArgsForCall, struct {
	}{})
	stub := fake.GetuidStub
	fakeReturns := fake.getuidReturns
	fake.recordInvocation("Getuid", []interface{}{})
	fake.getuidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) GetuidCallCount() int {
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	return len(fake.getuidArgsForCall)
}

func (fake *FakeOs) GetuidCalls(stub func() int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = stub
}

func (fake *FakeOs) GetuidReturns(result1 int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = nil
	fake.getuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) GetuidReturnsOnCall(i int, result1 int) {
	fake.getuidMutex.Lock()
	defer fake.getuidMutex.Unlock()
	fake.GetuidStub = nil
	if fake.getuidReturnsOnCall == nil {
		fake.getuidReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getuidReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getwd() (string, error) {
	fake.getwdMutex.Lock()
	ret, specificReturn := fake.getwdReturnsOnCall[len(fake.getwdArgsForCall)]
	fake.getwdArgsForCall = append(fake.getwdArgsForCall, struct {
	}{})
	stub := fake.GetwdStub
	fakeReturns := fake.getwdReturns
	fake.recordInvocation("Getwd", []interface{}{})
	fake.getwdMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) GetwdCallCount() int {
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	return len(fake.getwdArgsForCall)
}

func (fake *FakeOs) GetwdCalls(stub func() (string, error)) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = stub
}

func (fake *FakeOs) GetwdReturns(result1 string, result2 error) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = nil
	fake.getwdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) GetwdReturnsOnCall(i int, result1 string, result2 error) {
	fake.getwdMutex.Lock()
	defer fake.getwdMutex.Unlock()
	fake.GetwdStub = nil
	if fake.getwdReturnsOnCall == nil {
		fake.getwdReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getwdReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Hostname() (string, error) {
	fake.hostnameMutex.Lock()
	ret, specificReturn := fake.hostnameReturnsOnCall[len(fake.hostnameArgsForCall)]
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct {
	}{})
	stub := fake.HostnameStub
	fakeReturns := fake.hostnameReturns
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeOs) HostnameCalls(stub func() (string, error)) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = stub
}

func (fake *FakeOs) HostnameReturns(result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) HostnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	if fake.hostnameReturnsOnCall == nil {
		fake.hostnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.hostnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) IsExist(arg1 error) bool {
	fake.isExistMutex.Lock()
	ret, specificReturn := fake.isExistReturnsOnCall[len(fake.isExistArgsForCall)]
	fake.isExistArgsForCall = append(fake.isExistArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsExistStub
	fakeReturns := fake.isExistReturns
	fake.recordInvocation("IsExist", []interface{}{arg1})
	fake.isExistMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) IsExistCallCount() int {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	return len(fake.isExistArgsForCall)
}

func (fake *FakeOs) IsExistCalls(stub func(error) bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = stub
}

func (fake *FakeOs) IsExistArgsForCall(i int) error {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	argsForCall := fake.isExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsExistReturns(result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	fake.isExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsExistReturnsOnCall(i int, result1 bool) {
	fake.isExistMutex.Lock()
	defer fake.isExistMutex.Unlock()
	fake.IsExistStub = nil
	if fake.isExistReturnsOnCall == nil {
		fake.isExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsNotExist(arg1 error) bool {
	fake.isNotExistMutex.Lock()
	ret, specificReturn := fake.isNotExistReturnsOnCall[len(fake.isNotExistArgsForCall)]
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsNotExistStub
	fakeReturns := fake.isNotExistReturns
	fake.recordInvocation("IsNotExist", []interface{}{arg1})
	fake.isNotExistMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakeOs) IsNotExistCalls(stub func(error) bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = stub
}

func (fake *FakeOs) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	argsForCall := fake.isNotExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsNotExistReturns(result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsNotExistReturnsOnCall(i int, result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	if fake.isNotExistReturnsOnCall == nil {
		fake.isNotExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNotExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPathSeparator(arg1 uint8) bool {
	fake.isPathSeparatorMutex.Lock()
	ret, specificReturn := fake.isPathSeparatorReturnsOnCall[len(fake.isPathSeparatorArgsForCall)]
	fake.isPathSeparatorArgsForCall = append(fake.isPathSeparatorArgsForCall, struct {
		arg1 uint8
	}{arg1})
	stub := fake.IsPathSeparatorStub
	fakeReturns := fake.isPathSeparatorReturns
	fake.recordInvocation("IsPathSeparator", []interface{}{arg1})
	fake.isPathSeparatorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) IsPathSeparatorCallCount() int {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	return len(fake.isPathSeparatorArgsForCall)
}

func (fake *FakeOs) IsPathSeparatorCalls(stub func(uint8) bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = stub
}

func (fake *FakeOs) IsPathSeparatorArgsForCall(i int) uint8 {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	argsForCall := fake.isPathSeparatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsPathSeparatorReturns(result1 bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = nil
	fake.isPathSeparatorReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPathSeparatorReturnsOnCall(i int, result1 bool) {
	fake.isPathSeparatorMutex.Lock()
	defer fake.isPathSeparatorMutex.Unlock()
	fake.IsPathSeparatorStub = nil
	if fake.isPathSeparatorReturnsOnCall == nil {
		fake.isPathSeparatorReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPathSeparatorReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPermission(arg1 error) bool {
	fake.isPermissionMutex.Lock()
	ret, specificReturn := fake.isPermissionReturnsOnCall[len(fake.isPermissionArgsForCall)]
	fake.isPermissionArgsForCall = append(fake.isPermissionArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsPermissionStub
	fakeReturns := fake.isPermissionReturns
	fake.recordInvocation("IsPermission", []interface{}{arg1})
	fake.isPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) IsPermissionCallCount() int {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	return len(fake.isPermissionArgsForCall)
}

func (fake *FakeOs) IsPermissionCalls(stub func(error) bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = stub
}

func (fake *FakeOs) IsPermissionArgsForCall(i int) error {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	argsForCall := fake.isPermissionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsPermissionReturns(result1 bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = nil
	fake.isPermissionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPermissionReturnsOnCall(i int, result1 bool) {
	fake.isPermissionMutex.Lock()
	defer fake.isPermissionMutex.Unlock()
	fake.IsPermissionStub = nil
	if fake.isPermissionReturnsOnCall == nil {
		fake.isPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPermissionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsTimeout(arg1 error) bool {
	fake.isTimeoutMutex.Lock()
	ret, specificReturn := fake.isTimeoutReturnsOnCall[len(fake.isTimeoutArgsForCall)]
	fake.isTimeoutArgsForCall = append(fake.isTimeoutArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.IsTimeoutStub
	fakeReturns := fake.isTimeoutReturns
	fake.recordInvocation("IsTimeout", []interface{}{arg1})
	fake.isTimeoutMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) IsTimeoutCallCount() int {
	fake.isTimeoutMutex.RLock()
	defer fake.isTimeoutMutex.RUnlock()
	return len(fake.isTimeoutArgsForCall)
}

func (fake *FakeOs) IsTimeoutCalls(stub func(error) bool) {
	fake.isTimeoutMutex.Lock()
	defer fake.isTimeoutMutex.Unlock()
	fake.IsTimeoutStub = stub
}

func (fake *FakeOs) IsTimeoutArgsForCall(i int) error {
	fake.isTimeoutMutex.RLock()
	defer fake.isTimeoutMutex.RUnlock()
	argsForCall := fake.isTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) IsTimeoutReturns(result1 bool) {
	fake.isTimeoutMutex.Lock()
	defer fake.isTimeoutMutex.Unlock()
	fake.IsTimeoutStub = nil
	fake.isTimeoutReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsTimeoutReturnsOnCall(i int, result1 bool) {
	fake.isTimeoutMutex.Lock()
	defer fake.isTimeoutMutex.Unlock()
	fake.IsTimeoutStub = nil
	if fake.isTimeoutReturnsOnCall == nil {
		fake.isTimeoutReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isTimeoutReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Lchown(arg1 string, arg2 int, arg3 int) error {
	fake.lchownMutex.Lock()
	ret, specificReturn := fake.lchownReturnsOnCall[len(fake.lchownArgsForCall)]
	fake.lchownArgsForCall = append(fake.lchownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.LchownStub
	fakeReturns := fake.lchownReturns
	fake.recordInvocation("Lchown", []interface{}{arg1, arg2, arg3})
	fake.lchownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) LchownCallCount() int {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return len(fake.lchownArgsForCall)
}

func (fake *FakeOs) LchownCalls(stub func(string, int, int) error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = stub
}

func (fake *FakeOs) LchownArgsForCall(i int) (string, int, int) {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	argsForCall := fake.lchownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) LchownReturns(result1 error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = nil
	fake.lchownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LchownReturnsOnCall(i int, result1 error) {
	fake.lchownMutex.Lock()
	defer fake.lchownMutex.Unlock()
	fake.LchownStub = nil
	if fake.lchownReturnsOnCall == nil {
		fake.lchownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lchownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Link(arg1 string, arg2 string) error {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.LinkStub
	fakeReturns := fake.linkReturns
	fake.recordInvocation("Link", []interface{}{arg1, arg2})
	fake.linkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeOs) LinkCalls(stub func(string, string) error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = stub
}

func (fake *FakeOs) LinkArgsForCall(i int) (string, string) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	argsForCall := fake.linkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) LinkReturns(result1 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LinkReturnsOnCall(i int, result1 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) LookupEnv(arg1 string) (string, bool) {
	fake.lookupEnvMutex.Lock()
	ret, specificReturn := fake.lookupEnvReturnsOnCall[len(fake.lookupEnvArgsForCall)]
	fake.lookupEnvArgsForCall = append(fake.lookupEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LookupEnvStub
	fakeReturns := fake.lookupEnvReturns
	fake.recordInvocation("LookupEnv", []interface{}{arg1})
	fake.lookupEnvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) LookupEnvCallCount() int {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	return len(fake.lookupEnvArgsForCall)
}

func (fake *FakeOs) LookupEnvCalls(stub func(string) (string, bool)) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = stub
}

func (fake *FakeOs) LookupEnvArgsForCall(i int) string {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	argsForCall := fake.lookupEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) LookupEnvReturns(result1 string, result2 bool) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = nil
	fake.lookupEnvReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeOs) LookupEnvReturnsOnCall(i int, result1 string, result2 bool) {
	fake.lookupEnvMutex.Lock()
	defer fake.lookupEnvMutex.Unlock()
	fake.LookupEnvStub = nil
	if fake.lookupEnvReturnsOnCall == nil {
		fake.lookupEnvReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
		})
	}
	fake.lookupEnvReturnsOnCall[i] = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeOs) Lstat(arg1 string) (fs.FileInfo, error) {
	fake.lstatMutex.Lock()
	ret, specificReturn := fake.lstatReturnsOnCall[len(fake.lstatArgsForCall)]
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LstatStub
	fakeReturns := fake.lstatReturns
	fake.recordInvocation("Lstat", []interface{}{arg1})
	fake.lstatMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeOs) LstatCalls(stub func(string) (fs.FileInfo, error)) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = stub
}

func (fake *FakeOs) LstatArgsForCall(i int) string {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	argsForCall := fake.lstatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) LstatReturns(result1 fs.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) LstatReturnsOnCall(i int, result1 fs.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	if fake.lstatReturnsOnCall == nil {
		fake.lstatReturnsOnCall = make(map[int]struct {
			result1 fs.FileInfo
			result2 error
		})
	}
	fake.lstatReturnsOnCall[i] = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Mkdir(arg1 string, arg2 fs.FileMode) error {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		arg1 string
		arg2 fs.FileMode
	}{arg1, arg2})
	stub := fake.MkdirStub
	fakeReturns := fake.mkdirReturns
	fake.recordInvocation("Mkdir", []interface{}{arg1, arg2})
	fake.mkdirMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeOs) MkdirCalls(stub func(string, fs.FileMode) error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = stub
}

func (fake *FakeOs) MkdirArgsForCall(i int) (string, fs.FileMode) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	argsForCall := fake.mkdirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) MkdirReturns(result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirReturnsOnCall(i int, result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAll(arg1 string, arg2 fs.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
		arg2 fs.FileMode
	}{arg1, arg2})
	stub := fake.MkdirAllStub
	fakeReturns := fake.mkdirAllReturns
	fake.recordInvocation("MkdirAll", []interface{}{arg1, arg2})
	fake.mkdirAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOs) MkdirAllCalls(stub func(string, fs.FileMode) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakeOs) MkdirAllArgsForCall(i int) (string, fs.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) MkdirTemp(arg1 string, arg2 string) (string, error) {
	fake.mkdirTempMutex.Lock()
	ret, specificReturn := fake.mkdirTempReturnsOnCall[len(fake.mkdirTempArgsForCall)]
	fake.mkdirTempArgsForCall = append(fake.mkdirTempArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.MkdirTempStub
	fakeReturns := fake.mkdirTempReturns
	fake.recordInvocation("MkdirTemp", []interface{}{arg1, arg2})
	fake.mkdirTempMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) MkdirTempCallCount() int {
	fake.mkdirTempMutex.RLock()
	defer fake.mkdirTempMutex.RUnlock()
	return len(fake.mkdirTempArgsForCall)
}

func (fake *FakeOs) MkdirTempCalls(stub func(string, string) (string, error)) {
	fake.mkdirTempMutex.Lock()
	defer fake.mkdirTempMutex.Unlock()
	fake.MkdirTempStub = stub
}

func (fake *FakeOs) MkdirTempArgsForCall(i int) (string, string) {
	fake.mkdirTempMutex.RLock()
	defer fake.mkdirTempMutex.RUnlock()
	argsForCall := fake.mkdirTempArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) MkdirTempReturns(result1 string, result2 error) {
	fake.mkdirTempMutex.Lock()
	defer fake.mkdirTempMutex.Unlock()
	fake.MkdirTempStub = nil
	fake.mkdirTempReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) MkdirTempReturnsOnCall(i int, result1 string, result2 error) {
	fake.mkdirTempMutex.Lock()
	defer fake.mkdirTempMutex.Unlock()
	fake.MkdirTempStub = nil
	if fake.mkdirTempReturnsOnCall == nil {
		fake.mkdirTempReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.mkdirTempReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) NewFile(arg1 uintptr, arg2 string) *os.File {
	fake.newFileMutex.Lock()
	ret, specificReturn := fake.newFileReturnsOnCall[len(fake.newFileArgsForCall)]
	fake.newFileArgsForCall = append(fake.newFileArgsForCall, struct {
		arg1 uintptr
		arg2 string
	}{arg1, arg2})
	stub := fake.NewFileStub
	fakeReturns := fake.newFileReturns
	fake.recordInvocation("NewFile", []interface{}{arg1, arg2})
	fake.newFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) NewFileCallCount() int {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	return len(fake.newFileArgsForCall)
}

func (fake *FakeOs) NewFileCalls(stub func(uintptr, string) *os.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = stub
}

func (fake *FakeOs) NewFileArgsForCall(i int) (uintptr, string) {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	argsForCall := fake.newFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) NewFileReturns(result1 *os.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = nil
	fake.newFileReturns = struct {
		result1 *os.File
	}{result1}
}

func (fake *FakeOs) NewFileReturnsOnCall(i int, result1 *os.File) {
	fake.newFileMutex.Lock()
	defer fake.newFileMutex.Unlock()
	fake.NewFileStub = nil
	if fake.newFileReturnsOnCall == nil {
		fake.newFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
		})
	}
	fake.newFileReturnsOnCall[i] = struct {
		result1 *os.File
	}{result1}
}

func (fake *FakeOs) NewSyscallError(arg1 string, arg2 error) error {
	fake.newSyscallErrorMutex.Lock()
	ret, specificReturn := fake.newSyscallErrorReturnsOnCall[len(fake.newSyscallErrorArgsForCall)]
	fake.newSyscallErrorArgsForCall = append(fake.newSyscallErrorArgsForCall, struct {
		arg1 string
		arg2 error
	}{arg1, arg2})
	stub := fake.NewSyscallErrorStub
	fakeReturns := fake.newSyscallErrorReturns
	fake.recordInvocation("NewSyscallError", []interface{}{arg1, arg2})
	fake.newSyscallErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) NewSyscallErrorCallCount() int {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	return len(fake.newSyscallErrorArgsForCall)
}

func (fake *FakeOs) NewSyscallErrorCalls(stub func(string, error) error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = stub
}

func (fake *FakeOs) NewSyscallErrorArgsForCall(i int) (string, error) {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	argsForCall := fake.newSyscallErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) NewSyscallErrorReturns(result1 error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = nil
	fake.newSyscallErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) NewSyscallErrorReturnsOnCall(i int, result1 error) {
	fake.newSyscallErrorMutex.Lock()
	defer fake.newSyscallErrorMutex.Unlock()
	fake.NewSyscallErrorStub = nil
	if fake.newSyscallErrorReturnsOnCall == nil {
		fake.newSyscallErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newSyscallErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Open(arg1 string) (*os.File, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenStub
	fakeReturns := fake.openReturns
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeOs) OpenCalls(stub func(string) (*os.File, error)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeOs) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) OpenReturns(result1 *os.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenFile(arg1 string, arg2 int, arg3 fs.FileMode) (*os.File, error) {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 fs.FileMode
	}{arg1, arg2, arg3})
	stub := fake.OpenFileStub
	fakeReturns := fake.openFileReturns
	fake.recordInvocation("OpenFile", []interface{}{arg1, arg2, arg3})
	fake.openFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeOs) OpenFileCalls(stub func(string, int, fs.FileMode) (*os.File, error)) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = stub
}

func (fake *FakeOs) OpenFileArgsForCall(i int) (string, int, fs.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	argsForCall := fake.openFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) OpenFileReturns(result1 *os.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) OpenFileReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Pipe() (*os.File, *os.File, error) {
	fake.pipeMutex.Lock()
	ret, specificReturn := fake.pipeReturnsOnCall[len(fake.pipeArgsForCall)]
	fake.pipeArgsForCall = append(fake.pipeArgsForCall, struct {
	}{})
	stub := fake.PipeStub
	fakeReturns := fake.pipeReturns
	fake.recordInvocation("Pipe", []interface{}{})
	fake.pipeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeOs) PipeCallCount() int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return len(fake.pipeArgsForCall)
}

func (fake *FakeOs) PipeCalls(stub func() (*os.File, *os.File, error)) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = stub
}

func (fake *FakeOs) PipeReturns(result1 *os.File, result2 *os.File, result3 error) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = nil
	fake.pipeReturns = struct {
		result1 *os.File
		result2 *os.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOs) PipeReturnsOnCall(i int, result1 *os.File, result2 *os.File, result3 error) {
	fake.pipeMutex.Lock()
	defer fake.pipeMutex.Unlock()
	fake.PipeStub = nil
	if fake.pipeReturnsOnCall == nil {
		fake.pipeReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 *os.File
			result3 error
		})
	}
	fake.pipeReturnsOnCall[i] = struct {
		result1 *os.File
		result2 *os.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOs) ReadDir(arg1 string) ([]fs.DirEntry, error) {
	fake.readDirMutex.Lock()
	ret, specificReturn := fake.readDirReturnsOnCall[len(fake.readDirArgsForCall)]
	fake.readDirArgsForCall = append(fake.readDirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadDirStub
	fakeReturns := fake.readDirReturns
	fake.recordInvocation("ReadDir", []interface{}{arg1})
	fake.readDirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) ReadDirCallCount() int {
	fake.readDirMutex.RLock()
	defer fake.readDirMutex.RUnlock()
	return len(fake.readDirArgsForCall)
}

func (fake *FakeOs) ReadDirCalls(stub func(string) ([]fs.DirEntry, error)) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = stub
}

func (fake *FakeOs) ReadDirArgsForCall(i int) string {
	fake.readDirMutex.RLock()
	defer fake.readDirMutex.RUnlock()
	argsForCall := fake.readDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ReadDirReturns(result1 []fs.DirEntry, result2 error) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = nil
	fake.readDirReturns = struct {
		result1 []fs.DirEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ReadDirReturnsOnCall(i int, result1 []fs.DirEntry, result2 error) {
	fake.readDirMutex.Lock()
	defer fake.readDirMutex.Unlock()
	fake.ReadDirStub = nil
	if fake.readDirReturnsOnCall == nil {
		fake.readDirReturnsOnCall = make(map[int]struct {
			result1 []fs.DirEntry
			result2 error
		})
	}
	fake.readDirReturnsOnCall[i] = struct {
		result1 []fs.DirEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ReadFile(arg1 string) ([]byte, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStub
	fakeReturns := fake.readFileReturns
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeOs) ReadFileCalls(stub func(string) ([]byte, error)) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = stub
}

func (fake *FakeOs) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	argsForCall := fake.readFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ReadFileReturns(result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ReadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Readlink(arg1 string) (string, error) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadlinkStub
	fakeReturns := fake.readlinkReturns
	fake.recordInvocation("Readlink", []interface{}{arg1})
	fake.readlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeOs) ReadlinkCalls(stub func(string) (string, error)) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = stub
}

func (fake *FakeOs) ReadlinkArgsForCall(i int) string {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	argsForCall := fake.readlinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) ReadlinkReturns(result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) ReadlinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeOs) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeOs) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveAllStub
	fakeReturns := fake.removeAllReturns
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeOs) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeOs) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Rename(arg1 string, arg2 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameStub
	fakeReturns := fake.renameReturns
	fake.recordInvocation("Rename", []interface{}{arg1, arg2})
	fake.renameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeOs) RenameCalls(stub func(string, string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeOs) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SameFile(arg1 fs.FileInfo, arg2 fs.FileInfo) bool {
	fake.sameFileMutex.Lock()
	ret, specificReturn := fake.sameFileReturnsOnCall[len(fake.sameFileArgsForCall)]
	fake.sameFileArgsForCall = append(fake.sameFileArgsForCall, struct {
		arg1 fs.FileInfo
		arg2 fs.FileInfo
	}{arg1, arg2})
	stub := fake.SameFileStub
	fakeReturns := fake.sameFileReturns
	fake.recordInvocation("SameFile", []interface{}{arg1, arg2})
	fake.sameFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) SameFileCallCount() int {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	return len(fake.sameFileArgsForCall)
}

func (fake *FakeOs) SameFileCalls(stub func(fs.FileInfo, fs.FileInfo) bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = stub
}

func (fake *FakeOs) SameFileArgsForCall(i int) (fs.FileInfo, fs.FileInfo) {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	argsForCall := fake.sameFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SameFileReturns(result1 bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = nil
	fake.sameFileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) SameFileReturnsOnCall(i int, result1 bool) {
	fake.sameFileMutex.Lock()
	defer fake.sameFileMutex.Unlock()
	fake.SameFileStub = nil
	if fake.sameFileReturnsOnCall == nil {
		fake.sameFileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.sameFileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Setenv(arg1 string, arg2 string) error {
	fake.setenvMutex.Lock()
	ret, specificReturn := fake.setenvReturnsOnCall[len(fake.setenvArgsForCall)]
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetenvStub
	fakeReturns := fake.setenvReturns
	fake.recordInvocation("Setenv", []interface{}{arg1, arg2})
	fake.setenvMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeOs) SetenvCalls(stub func(string, string) error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = stub
}

func (fake *FakeOs) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	argsForCall := fake.setenvArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SetenvReturns(result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SetenvReturnsOnCall(i int, result1 error) {
	fake.setenvMutex.Lock()
	defer fake.setenvMutex.Unlock()
	fake.SetenvStub = nil
	if fake.setenvReturnsOnCall == nil {
		fake.setenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) StartProcess(arg1 string, arg2 []string, arg3 *os.ProcAttr) (*os.Process, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.startProcessMutex.Lock()
	ret, specificReturn := fake.startProcessReturnsOnCall[len(fake.startProcessArgsForCall)]
	fake.startProcessArgsForCall = append(fake.startProcessArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 *os.ProcAttr
	}{arg1, arg2Copy, arg3})
	stub := fake.StartProcessStub
	fakeReturns := fake.startProcessReturns
	fake.recordInvocation("StartProcess", []interface{}{arg1, arg2Copy, arg3})
	fake.startProcessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) StartProcessCallCount() int {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return len(fake.startProcessArgsForCall)
}

func (fake *FakeOs) StartProcessCalls(stub func(string, []string, *os.ProcAttr) (*os.Process, error)) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = stub
}

func (fake *FakeOs) StartProcessArgsForCall(i int) (string, []string, *os.ProcAttr) {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	argsForCall := fake.startProcessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) StartProcessReturns(result1 *os.Process, result2 error) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = nil
	fake.startProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) StartProcessReturnsOnCall(i int, result1 *os.Process, result2 error) {
	fake.startProcessMutex.Lock()
	defer fake.startProcessMutex.Unlock()
	fake.StartProcessStub = nil
	if fake.startProcessReturnsOnCall == nil {
		fake.startProcessReturnsOnCall = make(map[int]struct {
			result1 *os.Process
			result2 error
		})
	}
	fake.startProcessReturnsOnCall[i] = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Stat(arg1 string) (fs.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeOs) StatCalls(stub func(string) (fs.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeOs) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) StatReturns(result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) StatReturnsOnCall(i int, result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 fs.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Symlink(arg1 string, arg2 string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SymlinkStub
	fakeReturns := fake.symlinkReturns
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2})
	fake.symlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeOs) SymlinkCalls(stub func(string, string) error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakeOs) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) SymlinkReturns(result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) SymlinkReturnsOnCall(i int, result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) TempDir() string {
	fake.tempDirMutex.Lock()
	ret, specificReturn := fake.tempDirReturnsOnCall[len(fake.tempDirArgsForCall)]
	fake.tempDirArgsForCall = append(fake.tempDirArgsForCall, struct {
	}{})
	stub := fake.TempDirStub
	fakeReturns := fake.tempDirReturns
	fake.recordInvocation("TempDir", []interface{}{})
	fake.tempDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) TempDirCallCount() int {
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	return len(fake.tempDirArgsForCall)
}

func (fake *FakeOs) TempDirCalls(stub func() string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = stub
}

func (fake *FakeOs) TempDirReturns(result1 string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	fake.tempDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) TempDirReturnsOnCall(i int, result1 string) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	if fake.tempDirReturnsOnCall == nil {
		fake.tempDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tempDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Truncate(arg1 string, arg2 int64) error {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	stub := fake.TruncateStub
	fakeReturns := fake.truncateReturns
	fake.recordInvocation("Truncate", []interface{}{arg1, arg2})
	fake.truncateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeOs) TruncateCalls(stub func(string, int64) error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = stub
}

func (fake *FakeOs) TruncateArgsForCall(i int) (string, int64) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	argsForCall := fake.truncateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOs) TruncateReturns(result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) TruncateReturnsOnCall(i int, result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Unsetenv(arg1 string) error {
	fake.unsetenvMutex.Lock()
	ret, specificReturn := fake.unsetenvReturnsOnCall[len(fake.unsetenvArgsForCall)]
	fake.unsetenvArgsForCall = append(fake.unsetenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UnsetenvStub
	fakeReturns := fake.unsetenvReturns
	fake.recordInvocation("Unsetenv", []interface{}{arg1})
	fake.unsetenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) UnsetenvCallCount() int {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return len(fake.unsetenvArgsForCall)
}

func (fake *FakeOs) UnsetenvCalls(stub func(string) error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = stub
}

func (fake *FakeOs) UnsetenvArgsForCall(i int) string {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	argsForCall := fake.unsetenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOs) UnsetenvReturns(result1 error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = nil
	fake.unsetenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) UnsetenvReturnsOnCall(i int, result1 error) {
	fake.unsetenvMutex.Lock()
	defer fake.unsetenvMutex.Unlock()
	fake.UnsetenvStub = nil
	if fake.unsetenvReturnsOnCall == nil {
		fake.unsetenvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetenvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) UserCacheDir() (string, error) {
	fake.userCacheDirMutex.Lock()
	ret, specificReturn := fake.userCacheDirReturnsOnCall[len(fake.userCacheDirArgsForCall)]
	fake.userCacheDirArgsForCall = append(fake.userCacheDirArgsForCall, struct {
	}{})
	stub := fake.UserCacheDirStub
	fakeReturns := fake.userCacheDirReturns
	fake.recordInvocation("UserCacheDir", []interface{}{})
	fake.userCacheDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) UserCacheDirCallCount() int {
	fake.userCacheDirMutex.RLock()
	defer fake.userCacheDirMutex.RUnlock()
	return len(fake.userCacheDirArgsForCall)
}

func (fake *FakeOs) UserCacheDirCalls(stub func() (string, error)) {
	fake.userCacheDirMutex.Lock()
	defer fake.userCacheDirMutex.Unlock()
	fake.UserCacheDirStub = stub
}

func (fake *FakeOs) UserCacheDirReturns(result1 string, result2 error) {
	fake.userCacheDirMutex.Lock()
	defer fake.userCacheDirMutex.Unlock()
	fake.UserCacheDirStub = nil
	fake.userCacheDirReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) UserCacheDirReturnsOnCall(i int, result1 string, result2 error) {
	fake.userCacheDirMutex.Lock()
	defer fake.userCacheDirMutex.Unlock()
	fake.UserCacheDirStub = nil
	if fake.userCacheDirReturnsOnCall == nil {
		fake.userCacheDirReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.userCacheDirReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) UserConfigDir() (string, error) {
	fake.userConfigDirMutex.Lock()
	ret, specificReturn := fake.userConfigDirReturnsOnCall[len(fake.userConfigDirArgsForCall)]
	fake.userConfigDirArgsForCall = append(fake.userConfigDirArgsForCall, struct {
	}{})
	stub := fake.UserConfigDirStub
	fakeReturns := fake.userConfigDirReturns
	fake.recordInvocation("UserConfigDir", []interface{}{})
	fake.userConfigDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) UserConfigDirCallCount() int {
	fake.userConfigDirMutex.RLock()
	defer fake.userConfigDirMutex.RUnlock()
	return len(fake.userConfigDirArgsForCall)
}

func (fake *FakeOs) UserConfigDirCalls(stub func() (string, error)) {
	fake.userConfigDirMutex.Lock()
	defer fake.userConfigDirMutex.Unlock()
	fake.UserConfigDirStub = stub
}

func (fake *FakeOs) UserConfigDirReturns(result1 string, result2 error) {
	fake.userConfigDirMutex.Lock()
	defer fake.userConfigDirMutex.Unlock()
	fake.UserConfigDirStub = nil
	fake.userConfigDirReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) UserConfigDirReturnsOnCall(i int, result1 string, result2 error) {
	fake.userConfigDirMutex.Lock()
	defer fake.userConfigDirMutex.Unlock()
	fake.UserConfigDirStub = nil
	if fake.userConfigDirReturnsOnCall == nil {
		fake.userConfigDirReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.userConfigDirReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) UserHomeDir() (string, error) {
	fake.userHomeDirMutex.Lock()
	ret, specificReturn := fake.userHomeDirReturnsOnCall[len(fake.userHomeDirArgsForCall)]
	fake.userHomeDirArgsForCall = append(fake.userHomeDirArgsForCall, struct {
	}{})
	stub := fake.UserHomeDirStub
	fakeReturns := fake.userHomeDirReturns
	fake.recordInvocation("UserHomeDir", []interface{}{})
	fake.userHomeDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOs) UserHomeDirCallCount() int {
	fake.userHomeDirMutex.RLock()
	defer fake.userHomeDirMutex.RUnlock()
	return len(fake.userHomeDirArgsForCall)
}

func (fake *FakeOs) UserHomeDirCalls(stub func() (string, error)) {
	fake.userHomeDirMutex.Lock()
	defer fake.userHomeDirMutex.Unlock()
	fake.UserHomeDirStub = stub
}

func (fake *FakeOs) UserHomeDirReturns(result1 string, result2 error) {
	fake.userHomeDirMutex.Lock()
	defer fake.userHomeDirMutex.Unlock()
	fake.UserHomeDirStub = nil
	fake.userHomeDirReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) UserHomeDirReturnsOnCall(i int, result1 string, result2 error) {
	fake.userHomeDirMutex.Lock()
	defer fake.userHomeDirMutex.Unlock()
	fake.UserHomeDirStub = nil
	if fake.userHomeDirReturnsOnCall == nil {
		fake.userHomeDirReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.userHomeDirReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) WriteFile(arg1 string, arg2 []byte, arg3 fs.FileMode) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 fs.FileMode
	}{arg1, arg2Copy, arg3})
	stub := fake.WriteFileStub
	fakeReturns := fake.writeFileReturns
	fake.recordInvocation("WriteFile", []interface{}{arg1, arg2Copy, arg3})
	fake.writeFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOs) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeOs) WriteFileCalls(stub func(string, []byte, fs.FileMode) error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = stub
}

func (fake *FakeOs) WriteFileArgsForCall(i int) (string, []byte, fs.FileMode) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	argsForCall := fake.writeFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeOs) WriteFileReturns(result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) WriteFileReturnsOnCall(i int, result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createTempMutex.RLock()
	defer fake.createTempMutex.RUnlock()
	fake.dirFSMutex.RLock()
	defer fake.dirFSMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.executableMutex.RLock()
	defer fake.executableMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	fake.isTimeoutMutex.RLock()
	defer fake.isTimeoutMutex.RUnlock()
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.mkdirTempMutex.RLock()
	defer fake.mkdirTempMutex.RUnlock()
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	fake.readDirMutex.RLock()
	defer fake.readDirMutex.RUnlock()
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	fake.userCacheDirMutex.RLock()
	defer fake.userCacheDirMutex.RUnlock()
	fake.userConfigDirMutex.RLock()
	defer fake.userConfigDirMutex.RUnlock()
	fake.userHomeDirMutex.RLock()
	defer fake.userHomeDirMutex.RUnlock()
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOs) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.Os = new(FakeOs)
