// Code generated by counterfeiter. DO NOT EDIT.
package foofakes

import (
	"sync"

	fooa "github.com/maxbrunsfeld/counterfeiter/v6/fixtures/dup_packages/a/foo"
	foob "github.com/maxbrunsfeld/counterfeiter/v6/fixtures/dup_packages/b/foo"
	"github.com/maxbrunsfeld/counterfeiter/v6/fixtures/dup_packages/foo"
)

type FakeMultiAB struct {
	MineStub        func() foo.S
	mineMutex       sync.RWMutex
	mineArgsForCall []struct{}
	mineReturns     struct {
		result1 foo.S
	}
	mineReturnsOnCall map[int]struct {
		result1 foo.S
	}
	FromAStub        func() fooa.S
	fromAMutex       sync.RWMutex
	fromAArgsForCall []struct{}
	fromAReturns     struct {
		result1 fooa.S
	}
	fromAReturnsOnCall map[int]struct {
		result1 fooa.S
	}
	FromBStub        func() foob.S
	fromBMutex       sync.RWMutex
	fromBArgsForCall []struct{}
	fromBReturns     struct {
		result1 foob.S
	}
	fromBReturnsOnCall map[int]struct {
		result1 foob.S
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMultiAB) Mine() foo.S {
	fake.mineMutex.Lock()
	ret, specificReturn := fake.mineReturnsOnCall[len(fake.mineArgsForCall)]
	fake.mineArgsForCall = append(fake.mineArgsForCall, struct{}{})
	fake.recordInvocation("Mine", []interface{}{})
	fake.mineMutex.Unlock()
	if fake.MineStub != nil {
		return fake.MineStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mineReturns.result1
}

func (fake *FakeMultiAB) MineCallCount() int {
	fake.mineMutex.RLock()
	defer fake.mineMutex.RUnlock()
	return len(fake.mineArgsForCall)
}

func (fake *FakeMultiAB) MineCalls(stub func() foo.S) {
	fake.mineMutex.Lock()
	defer fake.mineMutex.Unlock()
	fake.MineStub = stub
}

func (fake *FakeMultiAB) MineReturns(result1 foo.S) {
	fake.mineMutex.Lock()
	defer fake.mineMutex.Unlock()
	fake.MineStub = nil
	fake.mineReturns = struct {
		result1 foo.S
	}{result1}
}

func (fake *FakeMultiAB) MineReturnsOnCall(i int, result1 foo.S) {
	fake.mineMutex.Lock()
	defer fake.mineMutex.Unlock()
	fake.MineStub = nil
	if fake.mineReturnsOnCall == nil {
		fake.mineReturnsOnCall = make(map[int]struct {
			result1 foo.S
		})
	}
	fake.mineReturnsOnCall[i] = struct {
		result1 foo.S
	}{result1}
}

func (fake *FakeMultiAB) FromA() fooa.S {
	fake.fromAMutex.Lock()
	ret, specificReturn := fake.fromAReturnsOnCall[len(fake.fromAArgsForCall)]
	fake.fromAArgsForCall = append(fake.fromAArgsForCall, struct{}{})
	fake.recordInvocation("FromA", []interface{}{})
	fake.fromAMutex.Unlock()
	if fake.FromAStub != nil {
		return fake.FromAStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fromAReturns.result1
}

func (fake *FakeMultiAB) FromACallCount() int {
	fake.fromAMutex.RLock()
	defer fake.fromAMutex.RUnlock()
	return len(fake.fromAArgsForCall)
}

func (fake *FakeMultiAB) FromACalls(stub func() fooa.S) {
	fake.fromAMutex.Lock()
	defer fake.fromAMutex.Unlock()
	fake.FromAStub = stub
}

func (fake *FakeMultiAB) FromAReturns(result1 fooa.S) {
	fake.fromAMutex.Lock()
	defer fake.fromAMutex.Unlock()
	fake.FromAStub = nil
	fake.fromAReturns = struct {
		result1 fooa.S
	}{result1}
}

func (fake *FakeMultiAB) FromAReturnsOnCall(i int, result1 fooa.S) {
	fake.fromAMutex.Lock()
	defer fake.fromAMutex.Unlock()
	fake.FromAStub = nil
	if fake.fromAReturnsOnCall == nil {
		fake.fromAReturnsOnCall = make(map[int]struct {
			result1 fooa.S
		})
	}
	fake.fromAReturnsOnCall[i] = struct {
		result1 fooa.S
	}{result1}
}

func (fake *FakeMultiAB) FromB() foob.S {
	fake.fromBMutex.Lock()
	ret, specificReturn := fake.fromBReturnsOnCall[len(fake.fromBArgsForCall)]
	fake.fromBArgsForCall = append(fake.fromBArgsForCall, struct{}{})
	fake.recordInvocation("FromB", []interface{}{})
	fake.fromBMutex.Unlock()
	if fake.FromBStub != nil {
		return fake.FromBStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fromBReturns.result1
}

func (fake *FakeMultiAB) FromBCallCount() int {
	fake.fromBMutex.RLock()
	defer fake.fromBMutex.RUnlock()
	return len(fake.fromBArgsForCall)
}

func (fake *FakeMultiAB) FromBCalls(stub func() foob.S) {
	fake.fromBMutex.Lock()
	defer fake.fromBMutex.Unlock()
	fake.FromBStub = stub
}

func (fake *FakeMultiAB) FromBReturns(result1 foob.S) {
	fake.fromBMutex.Lock()
	defer fake.fromBMutex.Unlock()
	fake.FromBStub = nil
	fake.fromBReturns = struct {
		result1 foob.S
	}{result1}
}

func (fake *FakeMultiAB) FromBReturnsOnCall(i int, result1 foob.S) {
	fake.fromBMutex.Lock()
	defer fake.fromBMutex.Unlock()
	fake.FromBStub = nil
	if fake.fromBReturnsOnCall == nil {
		fake.fromBReturnsOnCall = make(map[int]struct {
			result1 foob.S
		})
	}
	fake.fromBReturnsOnCall[i] = struct {
		result1 foob.S
	}{result1}
}

func (fake *FakeMultiAB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.mineMutex.RLock()
	defer fake.mineMutex.RUnlock()
	fake.fromAMutex.RLock()
	defer fake.fromAMutex.RUnlock()
	fake.fromBMutex.RLock()
	defer fake.fromBMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMultiAB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ foo.MultiAB = new(FakeMultiAB)
